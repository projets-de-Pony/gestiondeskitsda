"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const src_1 = require("../../../src");
const testSrc_1 = require("../../../src/testSrc");
const aes_ts_1 = require("aes-ts");
describe('CBCMode', () => {
    it('encrypt', () => {
        const modeOfOperation = new src_1.CBCMode();
        const iv = modeOfOperation.startEncryption();
        const block1 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        const block2 = (0, crypto_1.randomBytes)(16);
        const block3 = (0, crypto_1.randomBytes)(16);
        const encrypted1 = modeOfOperation.combineEncryption(block1, block => block);
        const encrypted2 = modeOfOperation.combineEncryption(block2, block => block);
        const encrypted3 = modeOfOperation.combineEncryption(block3, block => block);
        (0, testSrc_1.expect)(encrypted1).to.be.deep.equal(iv);
        (0, testSrc_1.expect)(encrypted2).to.be.deep.equal((0, src_1.xor)(block2, encrypted1));
        (0, testSrc_1.expect)(encrypted3).to.be.deep.equal((0, src_1.xor)(block3, encrypted2));
        (0, testSrc_1.expect)(modeOfOperation.finishEncryption()).to.be.deep.equal(new Uint8Array());
    });
    it('decrypt', () => {
        const modeOfOperation = new src_1.CBCMode();
        (0, testSrc_1.expect)(modeOfOperation.startDecryption()).to.be.deep.equal(new Uint8Array());
        const block1 = (0, crypto_1.randomBytes)(16);
        const block2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        const block3 = (0, crypto_1.randomBytes)(16);
        const decrypted1 = modeOfOperation.combineDecryption(block1, block => block);
        const decrypted2 = modeOfOperation.combineDecryption(block2, block => block);
        const decrypted3 = modeOfOperation.combineDecryption(block3, block => block);
        (0, testSrc_1.expect)(decrypted1).to.be.deep.equal(new Uint8Array());
        (0, testSrc_1.expect)(decrypted2).to.be.deep.equal(block1);
        (0, testSrc_1.expect)(decrypted3).to.be.deep.equal((0, src_1.xor)(block3, block2));
        (0, testSrc_1.expect)(modeOfOperation.finishDecryption()).to.be.deep.equal(new Uint8Array());
    });
    it('encrypt and decrypt trivial', () => {
        const modeOfOperation = new src_1.CBCMode();
        const iv = modeOfOperation.startEncryption();
        const block1 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        const block2 = (0, crypto_1.randomBytes)(16);
        const block3 = (0, crypto_1.randomBytes)(16);
        const encrypted1 = modeOfOperation.combineEncryption(block1, block => block);
        const encrypted2 = modeOfOperation.combineEncryption(block2, block => block);
        const encrypted3 = modeOfOperation.combineEncryption(block3, block => block);
        modeOfOperation.finishEncryption();
        modeOfOperation.startDecryption();
        modeOfOperation.combineDecryption(iv, block => block);
        const decrypted1 = modeOfOperation.combineDecryption(encrypted1, block => block);
        const decrypted2 = modeOfOperation.combineDecryption(encrypted2, block => block);
        const decrypted3 = modeOfOperation.combineDecryption(encrypted3, block => block);
        modeOfOperation.finishDecryption();
        (0, testSrc_1.expect)(decrypted1).to.be.deep.equal(block1);
        (0, testSrc_1.expect)(decrypted2).to.be.deep.equal(block2);
        (0, testSrc_1.expect)(decrypted3).to.be.deep.equal(block3);
    });
    it('encrypt and decrypt aes', () => {
        const blockCrypter = new aes_ts_1.Block((0, crypto_1.randomBytes)(16));
        const modeOfOperation = new src_1.CBCMode();
        const iv = modeOfOperation.startEncryption();
        const block1 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        const block2 = (0, crypto_1.randomBytes)(16);
        const block3 = (0, crypto_1.randomBytes)(16);
        const encrypted1 = modeOfOperation.combineEncryption(block1, block => blockCrypter.encrypt(block));
        const encrypted2 = modeOfOperation.combineEncryption(block2, block => blockCrypter.encrypt(block));
        const encrypted3 = modeOfOperation.combineEncryption(block3, block => blockCrypter.encrypt(block));
        modeOfOperation.finishEncryption();
        modeOfOperation.startDecryption();
        modeOfOperation.combineDecryption(iv, block => blockCrypter.decrypt(block));
        const decrypted1 = modeOfOperation.combineDecryption(encrypted1, block => blockCrypter.decrypt(block));
        const decrypted2 = modeOfOperation.combineDecryption(encrypted2, block => blockCrypter.decrypt(block));
        const decrypted3 = modeOfOperation.combineDecryption(encrypted3, block => blockCrypter.decrypt(block));
        modeOfOperation.finishDecryption();
        (0, testSrc_1.expect)(decrypted1).to.be.deep.equal(block1);
        (0, testSrc_1.expect)(decrypted2).to.be.deep.equal(block2);
        (0, testSrc_1.expect)(decrypted3).to.be.deep.equal(block3);
    });
});
