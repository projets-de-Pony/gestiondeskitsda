"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseFunctionsCaller = void 0;
const functions_1 = require("firebase/functions");
const bytesCoder_1 = require("../bytesCoder");
const messageAuthenticator_1 = require("../messageAuthenticator");
const utils_1 = require("../utils");
class FirebaseFunctionsCaller {
    options;
    functionsInstance;
    name;
    constructor(options, functionsInstance, name = null) {
        this.options = options;
        this.functionsInstance = functionsInstance;
        this.name = name;
    }
    function(key) {
        const name = this.name !== null ? `${this.name}-${key}` : key;
        return new FirebaseFunctionsCaller(this.options, this.functionsInstance, name);
    }
    createMacTag(parameters, key) {
        const messageAuthenticater = new messageAuthenticator_1.HMAC(key);
        const parametersBytesCoder = new bytesCoder_1.Utf8BytesCoder();
        const encodedParameters = parametersBytesCoder.encode(JSON.stringify(parameters));
        const rawTag = messageAuthenticater.sign(encodedParameters);
        const macTagByteCoder = new bytesCoder_1.HexBytesCoder();
        return macTagByteCoder.decode(rawTag);
    }
    async callFunction(parameters) {
        if (this.name === null)
            throw new Error('The function name must be defined');
        const flattenParameters = utils_1.Flattable.flatten(parameters);
        const macTag = this.createMacTag(flattenParameters, this.options.macKey);
        const callableFunction = (0, functions_1.httpsCallable)(this.functionsInstance, this.name);
        const response = await callableFunction({
            verboseLogger: true,
            macTag: macTag,
            parameters: flattenParameters
        });
        const result = utils_1.Result.from(response.data);
        return result.get();
    }
}
exports.FirebaseFunctionsCaller = FirebaseFunctionsCaller;
