"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expect = exports.Expect = exports.ExpectTo = exports.ExpectToBe = exports.ExpectToBeDeep = void 0;
const chai_1 = require("chai");
function isFirebaseErrorCode(code) {
    return [
        'ok', 'cancelled', 'unknown', 'invalid-argument', 'deadline-exceeded', 'not-found', 'already-exists',
        'permission-denied', 'resource-exhausted', 'failed-precondition', 'aborted', 'out-of-range', 'unimplemented',
        'internal', 'unavailable', 'data-loss', 'unauthenticated'
    ].includes(code);
}
class ExpectToBeDeep {
    value;
    constructor(value) {
        this.value = value;
    }
    equal(value, message) {
        return (0, chai_1.expect)(this.value).to.be.deep.equal(value, message);
    }
    unsorted(value, message) {
        (0, chai_1.assert)(Array.isArray(this.value));
        (0, chai_1.expect)(this.value.length).to.be.equal(value.length);
        for (const element of value) {
            const index = this.value.findIndex(elem => this.deepEqual(elem, element));
            if (index === -1)
                chai_1.assert.fail(message ?? `Couldn't find element: ${JSON.stringify(element)}`);
            this.value.splice(index, 1);
        }
    }
    deepEqual(value1, value2) {
        if (typeof value1 !== 'object' || value1 === null || typeof value2 !== 'object' || value2 === null)
            return value1 === value2;
        if (Array.isArray(value1) || Array.isArray(value2)) {
            if (!Array.isArray(value1) || !Array.isArray(value2))
                return false;
            if (value1.length !== value2.length)
                return false;
            for (let i = 0; i < value1.length; i++) {
                if (!this.deepEqual(value1[i], value2[i]))
                    return false;
            }
            return true;
        }
        const _value1 = this.removeUndefined(value1);
        const _value2 = this.removeUndefined(value2);
        if (Object.keys(_value1).length !== Object.keys(_value2).length)
            return false;
        for (const key of Object.keys(_value1)) {
            if (!(key in _value2))
                return false;
            if (!this.deepEqual(_value1[key], _value2[key]))
                return false;
        }
        return true;
    }
    removeUndefined(value) {
        const object = {};
        for (const key of Object.keys(value)) {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (value[key] !== undefined)
                object[key] = value[key];
        }
        return object;
    }
}
exports.ExpectToBeDeep = ExpectToBeDeep;
class ExpectToBe {
    value;
    constructor(value) {
        this.value = value;
    }
    get deep() {
        return new ExpectToBeDeep(this.value);
    }
    equal(value, message) {
        return (0, chai_1.expect)(this.value).to.be.equal(value, message);
    }
    get success() {
        (0, chai_1.assert)(typeof this.value === 'object' && this.value !== null && 'state' in this.value && (this.value.state === 'failure' || this.value.state === 'success'));
        const result = this.value;
        (0, chai_1.expect)(result.state).to.be.equal('success');
        (0, chai_1.assert)(result.state === 'success');
        return typeof result.value === 'object' ? new ExpectToBeDeep(result.value) : new ExpectToBe(result.value);
    }
    get failure() {
        (0, chai_1.assert)(typeof this.value === 'object' && this.value !== null && 'state' in this.value && (this.value.state === 'failure' || this.value.state === 'success'));
        const result = this.value;
        (0, chai_1.expect)(result.state).to.be.equal('failure');
        (0, chai_1.assert)(result.state === 'failure');
        return new ExpectToBeDeep(result.error);
    }
}
exports.ExpectToBe = ExpectToBe;
class ExpectTo {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    get be() {
        return new ExpectToBe(this._value);
    }
    throw(expected, message) {
        if (typeof expected === 'string' && isFirebaseErrorCode(expected)) {
            const executeValue = this._value;
            try {
                executeValue();
                return chai_1.expect.fail('Expected to throw an error.');
            }
            catch (error) {
                (0, chai_1.expect)(error).to.have.ownProperty('httpErrorCode');
                (0, chai_1.expect)(error).to.have.ownProperty('code');
                return (0, chai_1.expect)(error.code).to.be.equal(expected);
            }
        }
        return (0, chai_1.expect)(this._value).to.throw(expected, message);
    }
    async awaitThrow(expected) {
        const executeValue = this._value;
        await executeValue()
            .then(() => chai_1.expect.fail('Expected to throw an error.'))
            .catch(error => {
            if (error instanceof chai_1.AssertionError)
                throw error;
            if (expected !== undefined) {
                (0, chai_1.expect)(error).to.have.ownProperty('httpErrorCode');
                (0, chai_1.expect)(error).to.have.ownProperty('code');
                (0, chai_1.expect)(error.code).to.be.equal(expected);
            }
        });
    }
}
exports.ExpectTo = ExpectTo;
class Expect {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    get to() {
        return new ExpectTo(this._value);
    }
    value(key) {
        return new Expect(this._value[key]);
    }
}
exports.Expect = Expect;
function expect(value) {
    return new Expect(value);
}
exports.expect = expect;
(function (expect) {
    function fail(message) {
        chai_1.expect.fail(message);
    }
    expect.fail = fail;
})(expect = exports.expect || (exports.expect = {}));
