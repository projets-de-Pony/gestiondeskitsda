export type Result<T, E> = Result.Success<T> | Result.Failure<E>;
export declare namespace Result {
    type Value<R> = R extends Result<infer T, unknown> ? T : never;
    type Error<R> = R extends Result<unknown, infer E> ? E : never;
    class Success<T> {
        readonly value: T;
        readonly state = "success";
        constructor(value: T);
        get error(): null;
        get valueOrError(): T;
        get(): T;
        map<T2>(mapper: (value: T) => T2): Result<T2, never>;
        mapError(): Result<T, never>;
    }
    class Failure<E> {
        readonly error: E;
        readonly state = "failure";
        constructor(error: E);
        get value(): null;
        get valueOrError(): E;
        get(): never;
        map(): Result<never, E>;
        mapError<E2>(mapper: (value: E) => E2): Result<never, E2>;
    }
    function success<T>(value: T): Result<T, never>;
    function success(): Result<void, never>;
    function failure<E>(error: E): Result<never, E>;
    function isSuccess<T, E>(result: Result<T, E>): result is Result.Success<T>;
    function isFailure<T, E>(result: Result<T, E>): result is Result.Failure<E>;
    function from<T = unknown, E = unknown>(value: unknown): Result<T, E>;
}
