"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AES = void 0;
const aes_ts_1 = require("aes-ts");
const ICrypter_1 = require("./ICrypter");
const modeOfOperation_1 = require("./modeOfOperation");
const padding_1 = require("./padding");
class AES extends ICrypter_1.ICrypter {
    blockCrypter;
    modeOfOperation;
    blockSize = 16;
    constructor(key, modeOfOperation = null, padding = new padding_1.PKCS7Padding()) {
        super(padding);
        this.modeOfOperation = modeOfOperation ?? new modeOfOperation_1.CBCMode();
        if (key.length !== 16 && key.length !== 24 && key.length !== 32)
            throw new Error('AES key must be 16, 24 or 32 bytes long.');
        this.blockCrypter = new aes_ts_1.Block(key);
    }
    encryptBlocks(data) {
        let encrypted = this.modeOfOperation.startEncryption();
        for (let i = 0; i < data.length / 16; i++) {
            const encryptedBlock = this.modeOfOperation.combineEncryption(data.slice(16 * i, 16 * (i + 1)), block => this.blockCrypter.encrypt(block));
            encrypted = new Uint8Array([...encrypted, ...encryptedBlock]);
        }
        return new Uint8Array([...encrypted, ...this.modeOfOperation.finishEncryption()]);
    }
    decryptBlocks(data) {
        let decrypted = this.modeOfOperation.startDecryption();
        for (let i = 0; i < data.length / 16; i++) {
            const decryptedBlock = this.modeOfOperation.combineDecryption(data.slice(16 * i, 16 * (i + 1)), block => this.blockCrypter.decrypt(block));
            decrypted = new Uint8Array([...decrypted, ...decryptedBlock]);
        }
        return new Uint8Array([...decrypted, ...this.modeOfOperation.finishDecryption()]);
    }
}
exports.AES = AES;
